model Practica1

class Empleado
attributes
nombre : String
dni : String
edad : Integer
end

class Director < Empleado
end

class Gerente < Empleado
end

class TrabajadorBase < Empleado
end

class Empresa
attributes
nombre : String
nEmpleados : Integer
productos : Integer
valMinPedidos : Integer
end

class Producto
attributes
nombre : String
ID : Integer
precio : vendeProducto
unidades : productoPedido
end

class Cliente
attributes
eurosGastados : Integer
usuario : String
contrasena : String
end

class Vip < Cliente
end


class Pedido
attributes
fecha : String
precioTotal2 : Real derive :
self.dentroDelPedido->iterate(producto ; acumulador : Integer = 0 | acumulador + (producto.productoPedido.unidades->sum() * producto.vendeProducto.precio->sum()))
end

--association trabajaEn between
--Empleado [1] role empleado
--Empresa [1..3] role trabajo
--end

associationclass trabajaEn between
Empleado [1..*] role empleado
Empresa [0..3] role trabajo
attributes
salario : Integer
end

association Direccion between
Director[1] role dirigida_por
Empresa[1..3] role dirige
end

association Gerencia between
Gerente [1] role supervisada_por
Empresa [1..3] role supervisa
end

associationclass vendeProducto between
Empresa[1..*] role vendedor
Producto[1..*] role producto
attributes
precio : Integer
stock : Integer
end

associationclass productoPedido between
Pedido[1..*] role pedido_al_que_pertenece
Producto[1..*] role dentroDelPedido
attributes
unidades : Integer
end

association EmpleadoEsVipDeEmpresa between
Empleado[0..*] role esVip
Vip[0..*] role empleadoVip
end

association clientesDeUnaEmpresa between
Empresa[1..*] role tieneClientes
Cliente[0..*] role usuarioDeEmpresa
end

association clienteHacePedido between
Cliente[1..*] role comprador
Pedido[1..*] role pedidoCliente
end

constraints

--En otro programa que no fuera USE, esto seria un subtipado de relacion trabajaEn
--Si un director dirige una empresa, en alguna de las empresas en las que trabaja tiene que figurar el como director
context Director inv Director_Subtipado:
    self.trabajaEn->notEmpty() and 
    self.trabajaEn->forAll(empresas_de_un_trabajador | 
        self.dirige->exists(empresas_que_dirige | empresas_que_dirige = empresas_de_un_trabajador)
    )

--En otro programa que no fuera USE, esto seria un subtipado de relacion
--Si un gerente regenta una empresa, en alguna de las empresas en las que trabaja tiene que figurar el como gerente
context Gerente inv Gerente_Subtipado:
    self.trabajaEn->notEmpty() and 
    self.trabajaEn->forAll(empresas_de_un_trabajador | 
        self.supervisa->exists(empresas_que_supervisa | empresas_que_supervisa = empresas_de_un_trabajador)
    )

--Un director tiene que dirigir, si no seria trabajador base
context Director inv Director_dirige:
    self.dirige -> notEmpty()

--Un gerente tiene que supervisar, si no seria trabajador base
context Gerente inv Gerente_supervisa:
    self.supervisa -> notEmpty()

--constraints carla

-- Un director cobra más que un gerente dentro de una misma empresa 2 como el profe dice
context Director inv directorCobraMasQueGerente:
self.trabajaEn.salario->asSequence()->max() > self.dirige.supervisada_por.trabajaEn.salario->asSequence()->max()

--Un gerente cobra más que los trabajadores base dentro de una misma empresa
--probar en vez de max() con first()
context Gerente inv gerenteCobraMasQueTrabajadoresBase:
self.trabajaEn.salario->asSequence()->max() >
self.supervisa.empleado->select(oclIsTypeOf(TrabajadorBase)).trabajaEn.salario->asSequence()->max()

--Un director cobra más que los trabajadores base dentro de una misma empresa
--(esta restricción y la de arriba podrían unirse
--en una sola, ya lo bichearé, pero dividiendola se queda mas sencilla)
context Director inv directorCobraMasQueTrabajadoresBase:
self.trabajaEn.salario->asSequence()->max() > 
self.dirige.empleado->select(oclIsTypeOf(TrabajadorBase)).trabajaEn.salario->asSequence()->max()

--un empleado es vip de su propia empresa
--(no estoy segura de si esta restricción hay que añadirla, quizás se entiende con solo el diagrama)
context Empleado inv empleadoEsVipDeSuPropiaEmpresa:
self.trabajo->forAll(empresa | empresa.usuarioDeEmpresa->select(oclIsTypeOf(Vip))->includes(self))


--cliente es vip si ha realizado un pedido de más de 1000 euros
--context Cliente inv clienteEsVipDeUnaEmpresaSiHaceUnPedidoMayorDe1000Euros:
--self.pedidoCliente

--si es vip, tiene un 10% de descuento en todos sus nuevos pedidos

--si un empleado de una empresa hace un pedido, tiene un 10% de descuento

--Un director no puede ser gerente de su misma empresa (esto no sabría hacerlo, consultar)

--nadie puede hacer un pedido de artículos que no estén en el almacén

--cuando se realiza un pedido, desaparece del almacén (se resta 1 al stock supongo)

--una misma persona no puede tener artículos de más de 10 tipos de productos distintos, independientemente de
--la empresa en donde los compró

--constraints alba

-- Un empleado debe ser mayor de edad
context Empleado inv empleadoEdadMayorDeEdad:
self.edad >= 18

--Un pedido debe tener un valor minimo

--esto no funciona bien, porque no cuenta con que puedes pedir mas unidades de un mismo producto y asi llegar
--al tope del valor minimo. tendriamos que poner un atributo precioTotal en pedido y comprobar que ese precio total
--es mayor o igual al precio minimo que impone la empresa
--la sintaxis de pedidoValorMinimo2 es la que nos dijo el profe que era mejor implementar
context Pedido inv pedidoValorMinimo2:
self.dentroDelPedido->iterate(producto ; acumulador : Integer = 0 | acumulador + producto.vendeProducto.precio->asSequence()->first()) >=
self.dentroDelPedido.vendedor.valMinPedidos->iterate(e; acumulador: Integer = null | e)


-- Un pedido debe tener un valor mínimo
context Pedido inv pedidoValorMinimo:
-- esto da el problema de no poder aplicar la flecha a un producto individual, además el any() no se puede usar en este caso
--(self.dentroDelPedido->collect(p | p -> VendeProducto.precio)->sum()) >= self.dentroDelPedido->collect(p | p -> VendeProducto.valMinPedidos)->any()

self.dentroDelPedido->iterate(p ; acumulador : Integer = 0 | acumulador + p.precio.precio) >= self.dentroDelPedido.vendedor.valMinPedidos->iterate(e; acumulador: Integer = null | e)

-- Producto pedido debe estar en stock
context Pedido inv productoEnStock:
(self.dentroDelPedido->iterate(p; acumulador : Integer = 0 | if p.precio.stock >= 1 then acumulador +1 else acumulador endif)) = self.dentroDelPedido -> size()


